# -*- coding: utf-8 -*-
"""Copy of LSDS Intro Day 6 Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bj5i4sfNztLkIAP4UI9KEOtc-KDTH-G9

#Linear Algebra Applications Assignment

### Your data:

**chirps_per_sec** = chirps/sec for the striped ground cricket

**temperature** = temperature in degrees Fahrenheit

Reference: The Song of Insects by Dr.G.W. Pierce, Harvard College Press
"""



!pip install xlrd
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_excel('https://college.cengage.com/mathematics/brase/understandable_statistics/7e/students/datasets/slr/excel/slr02.xls')
df = df.rename(columns={'X':'chirps_per_sec', 'Y':'temperature'})

print(df.shape)
df.head()

"""## 1) Graph a scatterplot of chirps_per_sec vs temperature"""

x = df['temperature']
y = df['chirps_per_sec']
plt.scatter(x,y)
plt.show

"""## 2) Follow the steps below to compute the coefficients (intercept and slope) for the line of best fit:

## 2.1) Use np.ones to add a column of ones to the dataframe
"""

df['One'] = np.ones(15)

"""## 2.2) Create your X matrix from the 'ones' and 'temperature' columns"""

X = df[['One', 'temperature']].as_matrix()

"""## 2.3) Create your Y vector from the chips_per_sec column. (Make sure that it is formatted as a column vector.)"""

Y = df['chirps_per_sec'].as_matrix().reshape(-1,1)
print(Y)

"""## 2.4) Calculate X_transpose and print the result: $X^{T}$"""

X_transpose = np.transpose(X)
print(X_transpose)

"""## 2.5) Calculate X_transpose_X and print the result: $X^{T}X$"""

X_transpose_X = np.matmul(X_transpose, X)
print(X_transpose_X)

"""## 2.6) Calculate the inverse of X_transpose_X and print the result: $(X^{T}X)^{-1}$"""

inverse = np.linalg.inv(X_transpose_X)
print(inverse)

"""## 2.7) An aside: Multiply the X_tranpose_X matrix against its inverse: $(X^{T}X)(X^{T}X)^{-1}$  Print the result. What is the name for the resulting matrix?"""

multiplied = np.matmul(X_transpose_X, inverse)
print(multiplied)

"""## 2.8) Calculate X_transpose_Y and print the result: $X^{T}Y$"""

X_transpose_Y = np.matmul(X_transpose, Y)
print(X_transpose_Y)

"""## 2.9) Finally, calculate the Beta coefficients vector by multiplying the left and right halfs of the linear regression equation. Print the Beta vector: $\beta = (X^{T}X)^{-1} X^{T}Y$

> Indented block


(You should have all of the parts to do this now)
"""

beta = np.matmul(inverse,X_transpose_Y)
print(beta)

"""## 3) Graph the line of best fit through the scatterplot of the data points"""

beta_0 = beta[0,0]
beta_1 = beta[1,0]
temp = df['temperature']
chirps = df['chirps_per_sec']
plt.scatter(temp, chirps)
y_hat = [beta_1*x+ beta_0 for x in temp]
plt.plot(temp, y_hat)

y = 19
x = (y - beta_0)/beta_1
plt.axvline(x,linewidth=1, color='g')
plt.show()

"""## 4) If a cricket has chirped 19 times in a second what is the predicted temperature? Plot this prediction as well."""

print('Prediction:',x)
#added this as green vertical line in question 3

"""##Stretch Problem
Let's add a 3rd dimension. 

X1 = systolic blood pressure

X2 = age in years

X3 = weight in pounds

Compute the coefficients for the **plane** of best fit for

$X_1 = \beta_1X_2 + \beta_2X_3 + \beta_0$

Then graph the plane in addition to the  datapoints in a **3D** graph.
An article to get you started on [3D graphing](https://jakevdp.github.io/PythonDataScienceHandbook/04.12-three-dimensional-plotting.html)
"""

s_data = pd.read_excel('https://college.cengage.com/mathematics/brase/understandable_statistics/7e/students/datasets/mlr/excel/mlr02.xls')
print(s_data.head())
s_data.shape

s_data['One'] = np.ones(11)
X = s_data[['One', 'X2', 'X3']].as_matrix()
Y  = s_data['X1'].as_matrix().reshape(-1,1)

X_transpose = np.transpose(X)
X_transpose_X = np.matmul(X_transpose, X)
inverse = np.linalg.inv(X_transpose_X)
Y_X_transpose = np.matmul(X_transpose, Y)
beta = np.matmul(inverse, Y_X_transpose)
print(beta)

from mpl_toolkits import mplot3d
fig = plt.figure()
ax = plt.axes(projection='3d')
beta_0 = beta[0,0]
beta_1 = beta[1,0]
beta_2 = beta[2,0]
xdata = s_data['X1']
ydata = s_data['X2']
zdata = s_data['X3']
ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap='Reds')
#plotting line
y_hat_2 = [(x*beta_1) + (y*beta_2) + beta_0 for x in ydata for y in zdata]

print(beta_1)
